"""
Pytest Configuration and Fixtures
"""
import pytest
import asyncio
from unittest.mock import Mock, patch
import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


@pytest.fixture(scope="session")
def event_loop():
    """Create an instance of the event loop for the test session."""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()


@pytest.fixture
def mock_settings():
    """Mock settings for tests"""
    with patch('config.settings.settings') as mock:
        mock.APP_NAME = "OneDay.run Test"
        mock.APP_VERSION = "1.0.0-test"
        mock.DEBUG = True
        mock.SECRET_KEY = "test-secret"
        mock.ANTHROPIC_API_KEY = "test-anthropic-key"
        mock.GITHUB_TOKEN = "test-github-token"
        mock.GITHUB_ORG = "test-org"
        mock.RAILWAY_TOKEN = "test-railway"
        mock.VERCEL_TOKEN = "test-vercel"
        mock.RENDER_API_KEY = "test-render"
        mock.DATABASE_URL = "sqlite:///./test.db"
        mock.DEFAULT_MODEL = "anthropic/claude-opus-4-5-20251101"
        mock.MAX_TOKENS = 4096
        mock.TEMPERATURE = 0.7
        mock.PRICING_TIERS = {
            "1h": {"price": 150, "max_tokens": 50000},
            "8h": {"price": 1200, "max_tokens": 400000},
        }
        yield mock


@pytest.fixture
def mock_github():
    """Mock GitHub client"""
    with patch('src.services.github_service.Github') as mock:
        mock_user = Mock()
        mock_user.login = "test-user"
        mock_instance = mock.return_value
        mock_instance.get_user.return_value = mock_user
        yield mock_instance


@pytest.fixture
def mock_litellm():
    """Mock LiteLLM for LLM calls"""
    with patch('litellm.acompletion') as mock:
        async def mock_completion(*args, **kwargs):
            class MockChoice:
                def __init__(self):
                    self.message = Mock(content="Mock response", tool_calls=None)
                    self.delta = Mock(content="Mock ", tool_calls=None)
            
            class MockResponse:
                def __init__(self):
                    self.choices = [MockChoice()]
            
            if kwargs.get('stream'):
                async def stream_gen():
                    for word in ["Mock", " ", "response"]:
                        choice = MockChoice()
                        choice.delta.content = word
                        yield Mock(choices=[choice])
                return stream_gen()
            return MockResponse()
        
        mock.side_effect = mock_completion
        yield mock


@pytest.fixture
def sample_project_data():
    """Sample project data for tests"""
    return {
        "project_id": "test-001",
        "client_name": "Test Client",
        "tier": "8h",
        "initial_message": "Build me a REST API for task management",
        "tech_stack": "python_fastapi",
        "project_type": "api"
    }


@pytest.fixture
def sample_component():
    """Sample component for tests"""
    from src.components.library import Component, ComponentCategory
    
    return Component(
        id="test-component",
        name="Test Component",
        description="A test component for unit tests",
        category=ComponentCategory.UTILS,
        tech_stack=["python"],
        files=[
            {"path": "test.py", "content": "# Test file\nprint('hello')"}
        ],
        dependencies=["pytest"],
        tags=["test", "sample"]
    )


@pytest.fixture
def sample_files():
    """Sample files for GitHub tests"""
    return [
        {"path": "src/__init__.py", "content": ""},
        {"path": "src/main.py", "content": "from fastapi import FastAPI\napp = FastAPI()"},
        {"path": "requirements.txt", "content": "fastapi>=0.100.0\nuvicorn>=0.23.0"},
        {"path": "README.md", "content": "# Test Project\n\nGenerated by OneDay.run"},
    ]


# Markers for slow/integration tests
def pytest_configure(config):
    config.addinivalue_line("markers", "slow: marks tests as slow")
    config.addinivalue_line("markers", "integration: marks tests as integration tests")
    config.addinivalue_line("markers", "e2e: marks tests as end-to-end tests")
